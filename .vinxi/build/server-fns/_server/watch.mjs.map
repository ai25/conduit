{"version":3,"file":"watch.mjs","sources":["../../../../src/utils/hls.ts","../../../../src/components/RelatedVideos.tsx","../../../../src/components/Bottomsheet.tsx","../../../../src/components/Comment.tsx","../../../../src/components/Comments.tsx","../../../../src/routes/watch.tsx?pick=default&pick=$css"],"sourcesContent":["import { PipedVideo, Subtitle } from \"~/types\";\nimport { ttml2srt } from \"../lib/ttml.js\";\n\n/**\n * Modify an HLS (HTTP Live Streaming) manifest to isolate a specific bandwidth and its corresponding audio and video URLs.\n *\n * @param manifest {string} - The original HLS manifest.\n * @param bandwidth {string} - The target bandwidth for filtering streams.\n *\n * @returns {Object} An object containing the updated manifest, selected audio URL, and selected video URL.\n * - updatedManifest {string} - The modified HLS manifest.\n * - selectedAudioUrl {string|null} - The selected audio URL, or null if not found.\n * - selectedVideoUrl {string|null} - The selected video URL, or null if not found.\n *\n * @throws Will throw an error if the manifest does not start with \"#EXTM3U\".\n */\nexport function modifyManifest(\n  manifest: string,\n  bandwidth: string\n): {\n  updatedManifest: string;\n  selectedAudioUrl: string | null;\n  selectedVideoUrl: string | null;\n} {\n  if (!manifest.startsWith(\"#EXTM3U\")) {\n    throw new Error(\"Not a valid manifest file\");\n  }\n  const lines = manifest.split(\"\\n\");\n\n  let selectedAudioChannel: string | null = null;\n  let selectedAudioUrl: string | null = null;\n  let selectedVideoUrl: string | null = null;\n  let output: string[] = [];\n\n  // get the audio channel\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (\n      line.startsWith(\"#EXT-X-STREAM-INF\") &&\n      line.includes(`BANDWIDTH=${bandwidth}`)\n    ) {\n      const audioMatch = line.match(/AUDIO=\"(\\d+)\"/);\n      if (audioMatch) {\n        selectedAudioChannel = audioMatch[1];\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (line.startsWith(\"#EXT-X-STREAM-INF\")) {\n      // check if this line contains the chosen bandwidth\n      if (line.includes(`BANDWIDTH=${bandwidth}`)) {\n        // add the line to the output\n        output.push(line);\n\n        if (i + 1 < lines.length) {\n          selectedVideoUrl = lines[i + 1];\n          output.push(\"{video}\");\n          i++; // skip the next line as we've replaced it\n        }\n      } else {\n        i++; // skip the next url as it's irrelevant\n      }\n    } else if (line.startsWith(\"#EXT-X-MEDIA\")) {\n      const uriMatch = line.match(/URI=\"([^\"]+)\"/);\n      if (selectedAudioChannel !== null) {\n        // check if this line contains the chosen audio channel\n        if (line.includes(`GROUP-ID=\"${selectedAudioChannel}\"`)) {\n          // store the audio url and replace the uri with \"{audio}\"\n          if (uriMatch) {\n            selectedAudioUrl = uriMatch[1];\n          }\n          const replacedLine = line.replace(/URI=\"[^\"]+\"/, 'URI=\"{audio}\"');\n          output.push(replacedLine);\n        }\n      }\n    } else {\n      // keep all other relevant lines\n      output.push(line);\n    }\n  }\n\n  const result = {\n    updatedManifest: output.join(\"\\n\"),\n    selectedAudioUrl: selectedAudioUrl,\n    selectedVideoUrl: selectedVideoUrl,\n  };\n\n  return result;\n}\n\n/**\n * Modify a VOD (Video-On-Demand) HLS manifest to isolate segment information and metadata.\n *\n * @param manifest {string} - The original HLS VOD manifest.\n *\n * @returns {Object} An object containing the updated manifest, map, and list of segments.\n * - modifiedManifest {string} - The modified HLS VOD manifest.\n * - map {string} - The URL of the map (Initialization segment), or an empty string if not found.\n * - segments {string[]} - An array containing the URLs of the video segments.\n */\nexport function modifyManifestVOD(manifest: string): {\n  modifiedManifest: string;\n  map: string;\n  segments: string[];\n} {\n  // Split the manifest by lines\n  const lines = manifest.split(\"\\n\");\n\n  let output: string[] = [];\n  let map: string = \"\";\n  let segments: string[] = [];\n\n  // Process each line\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (line.startsWith(\"#EXT-X-MAP\")) {\n      i++;\n      // Extract map URI\n      // const mapMatch = line.match(/URI=\"([^\"]+)\"/);\n      // if (mapMatch) {\n      //   map = mapMatch[1];\n      // }\n      // // Replace the URI with \"{map}\"\n      // const replacedLine = line.replace(/URI=\"[^\"]+\"/, 'URI=\"{map}\"');\n      // output.push(replacedLine);\n    } else if (line.startsWith(\"#EXTINF\")) {\n      // Add the #EXTINF line to the output\n      output.push(line);\n      if (i + 1 < lines.length) {\n        segments.push(lines[i + 1]); // Add the URL to segments\n        output.push(\"{segment}\");\n        i++; // Skip the next line as we've replaced it\n      }\n    } else {\n      // Keep lines that aren't map or #EXTINF info\n      output.push(line);\n    }\n  }\n\n  return {\n    modifiedManifest: output.join(\"\\n\"),\n    map: map,\n    segments: segments,\n  };\n}\n\n/**\n * Fetch and save video segments to a local directory.\n *\n * @param {string} instance - The base URL where the segments are located.\n * @param {string} dirName - The directory name where the segments will be saved.\n * @param {string[]} segments - An array containing the segment URLs.\n * @param {number} [maxRetries=3] - The maximum number of retries to fetch a segment.\n *\n * @returns {Promise<string[]>} A Promise resolving to an array of local segment names.\n *\n * @throws Will throw an error if the directory handle is not obtained.\n */\n\nconst filterVideoInfo = (videoData: PipedVideo) => {\n  return {\n    title: videoData.title,\n    description: videoData.description,\n    uploadDate: videoData.uploadDate,\n    uploader: videoData.uploader,\n    uploaderUrl: videoData.uploaderUrl,\n    category: videoData.category,\n    license: videoData.license,\n    visibility: videoData.visibility,\n    tags: videoData.tags,\n    duration: videoData.duration,\n    uploaderVerified: videoData.uploaderVerified,\n    views: videoData.views,\n    likes: videoData.likes,\n    dislikes: videoData.dislikes,\n    uploaderSubscriberCount: videoData.uploaderSubscriberCount,\n    chapters: videoData.chapters,\n    subtitles: videoData.subtitles.map((sub) => sub.code),\n    previewFrames: videoData.previewFrames,\n  };\n};\n\nasync function fetchVideoData(\n  videoId: string,\n  apiUrl: string\n): Promise<PipedVideo> {\n  const response = await fetch(`${apiUrl}/streams/${videoId}`);\n  const videoData = (await response.json()) as PipedVideo;\n  if (!videoData || (videoData as any).error) {\n    throw new Error(\n      `Failed to fetch video data for ${videoId}: ${response.status} ${response.statusText}`\n    );\n  }\n  return videoData;\n}\ninterface SaveParams<T> {\n  data: T;\n  handle: FileSystemFileHandle;\n}\n\nasync function saveAsset<T>({ data, handle }: SaveParams<T>): Promise<void> {\n  const writableStream = await (handle as any).createWritable();\n  await writableStream.write(data);\n  await writableStream.close();\n}\n\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number\n): Promise<T> {\n  let retries = 0;\n  while (true) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (retries >= maxRetries) {\n        throw new Error(`Failed after ${maxRetries} retries.`);\n      }\n      retries++;\n    }\n  }\n}\n\nexport async function fetchSegments(\n  instance: string,\n  segments: string[],\n  maxRetries: number = 3\n): Promise<Blob[]> {\n  const localSegments: Blob[] = [];\n\n  outer: for (let i = 0; i < segments.length; i++) {\n    try {\n      const segmentData = await fetchAssetData(\n        async (url) =>\n          await retry(async () => await fetchBlob(url), maxRetries),\n        { url: `${instance}${segments[i]}` }\n      );\n      if (!segmentData) {\n        throw new Error(\"Failed to fetch segment data.\");\n      }\n      localSegments.push(segmentData);\n    } catch (error) {\n      console.error(`Error fetching or saving segment ${i}:`, error);\n      break outer;\n    }\n  }\n  if (localSegments.length !== segments.length) {\n    throw new Error(\"Failed to fetch all segments.\");\n  }\n\n  return localSegments;\n}\n\ntype Fetcher<T> = (url: string) => Promise<T>;\n\nexport async function fetchAssetData<T>(\n  fetcher: Fetcher<T>,\n  { url }: { url: string }\n): Promise<T> {\n  const data = await fetcher(url);\n  return data;\n}\n\nexport const fetchText = async (url: string) => {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(\n      `Failed to fetch ${url}: ${response.status} ${response.statusText}`\n    );\n  }\n  return await response.text();\n};\n\nexport const fetchBlob = async (url: string) => {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(\n      `Failed to fetch ${url}: ${response.status} ${response.statusText}`\n    );\n  }\n  return await response.blob();\n};\n\n/* Download a video including its metadata, segments, and other assets.\n *\n * @param {string} videoId - The ID of the video to be downloaded.\n * @param {string} [apiUrl=\"https://pipedapi.kavin.rocks\"] - The API endpoint to fetch video details.\n *\n * @throws Will throw an error if downloading the video fails at any stage.\n */\nexport async function downloadVideo(\n  videoId: string,\n  apiUrl: string = \"https://pipedapi.kavin.rocks\",\n  resolution: string = \"1080\",\n  subtitleCode?: string\n) {\n  try {\n    console.log(\"Fetching video data...\");\n\n    const videoData = await fetchVideoData(videoId, apiUrl);\n    console.log(\"Video data fetched.\", videoData);\n\n    console.log(\"Getting directory handle...\");\n    const root = await navigator.storage.getDirectory();\n    const videoDir = await root.getDirectoryHandle(videoId, {\n      create: true,\n    });\n    const streamsHandle = await videoDir.getFileHandle(\"streams.json\", {\n      create: true,\n    });\n\n    const filteredVideoInfo = filterVideoInfo(videoData);\n    console.log(\"Filtered video info:\", filteredVideoInfo);\n\n    console.log(\"Saving video info...\");\n    await saveAsset({\n      data: JSON.stringify(filteredVideoInfo),\n      handle: streamsHandle,\n    });\n    console.log(\"Video info saved.\");\n\n    const baseProxyUrl = videoData.hls.split(\"/api\")[0];\n\n    console.log(\"Fetching manifest...\");\n    const initialManifest = await fetchAssetData(\n      async (url) => {\n        return retry(async () => {\n          return await fetchText(url);\n        }, 3);\n      },\n      {\n        url: videoData.hls,\n      }\n    );\n    console.log(\"Manifest fetched.\", initialManifest);\n    if (!initialManifest || !initialManifest.includes(\"#EXTM3U\")) {\n      throw new Error(\"Failed to fetch manifest.\");\n    }\n\n    const findBandwithByResolution = (resolution: string, manifest: string) => {\n      const lines = manifest.split(\"\\n\");\n      const line = lines.find((line) => line.includes(resolution));\n      if (!line) throw new Error(`Could not find resolution ${resolution}`);\n      const bw = line.split(\"BANDWIDTH=\")?.[1]?.match(/([0-9])*/g)?.[0];\n      if (!bw)\n        throw new Error(\n          `Could not find the matching bandwidth for ${resolution}`\n        );\n      return bw;\n    };\n\n    const videoBandwidth = findBandwithByResolution(\n      resolution,\n      initialManifest\n    );\n    console.log(\"Video bandwidth:\", videoBandwidth);\n\n    const manifestResults = modifyManifest(initialManifest, videoBandwidth);\n\n    console.log(\"Modified manifest:\", manifestResults);\n    if (\n      !manifestResults ||\n      !manifestResults.updatedManifest ||\n      !manifestResults.updatedManifest.includes(\"#EXTM3U\")\n    ) {\n      throw new Error(\"Failed to modify manifest.\");\n    }\n\n    const manifestIndexHandle = await videoDir.getFileHandle(\"index.m3u8\", {\n      create: true,\n    });\n\n    console.log(\"Saving manifest...\");\n    saveAsset({\n      data: manifestResults.updatedManifest,\n      handle: manifestIndexHandle,\n    });\n    console.log(\"Manifest saved.\");\n\n    if (!manifestResults.selectedVideoUrl) {\n      throw new Error(\"Failed to find a matching video URL.\");\n    }\n    if (!manifestResults.selectedAudioUrl) {\n      throw new Error(\"Failed to find a matching audio URL.\");\n    }\n\n    console.log(\"Fetching audio manifest...\");\n    const audioManifestContent = await fetchAssetData(\n      async (url) => {\n        return retry(async () => {\n          return await fetchText(url);\n        }, 3);\n      },\n      {\n        url: `${baseProxyUrl}${manifestResults.selectedAudioUrl}`,\n      }\n    );\n    console.log(\"Audio manifest fetched.\", audioManifestContent);\n\n    console.log(\"Fetching video manifest...\");\n    const videoManifestContent = await fetchAssetData(\n      async (url) => {\n        return retry(async () => {\n          return await fetchText(url);\n        }, 3);\n      },\n      {\n        url: `${baseProxyUrl}${manifestResults.selectedVideoUrl}`,\n      }\n    );\n    console.log(\"Video manifest fetched.\", videoManifestContent);\n\n    const modifiedAudioManifest = modifyManifestVOD(audioManifestContent);\n    const modifiedVideoManifest = modifyManifestVOD(videoManifestContent);\n\n    console.log(\"Saving audio manifest...\");\n    const audioSegmentsDir = await videoDir.getDirectoryHandle(`audio`, {\n      create: true,\n    });\n    const audioFile = await audioSegmentsDir.getFileHandle(\"audio.m3u8\", {\n      create: true,\n    });\n    saveAsset({\n      data: modifiedAudioManifest.modifiedManifest,\n      handle: audioFile,\n    });\n    console.log(\"Audio manifest saved.\");\n\n    console.log(\"Saving video manifest...\");\n    const videoSegmentsDir = await videoDir.getDirectoryHandle(`video`, {\n      create: true,\n    });\n    const videoFile = await videoSegmentsDir.getFileHandle(\"video.m3u8\", {\n      create: true,\n    });\n    saveAsset({\n      data: modifiedVideoManifest.modifiedManifest,\n      handle: videoFile,\n    });\n    console.log(\"Video manifest saved.\");\n\n    console.log(\"Fetching audio segments...\");\n    const audioSegments = await fetchSegments(\n      baseProxyUrl,\n      modifiedAudioManifest.segments,\n      3\n    );\n    console.log(\"Audio segments fetched.\", audioSegments);\n\n    console.log(\"Saving audio segments...\");\n    for (let i = 0; i < audioSegments.length; i++) {\n      const segmentName = `segment-${i}.ts`;\n      const segmentHandle = await audioSegmentsDir.getFileHandle(segmentName, {\n        create: true,\n      });\n      saveAsset({\n        data: audioSegments[i],\n        handle: segmentHandle,\n      });\n    }\n    console.log(\"Audio segments saved.\");\n\n    console.log(\"Fetching video segments...\");\n    const videoSegments = await fetchSegments(\n      baseProxyUrl,\n      modifiedVideoManifest.segments,\n      3\n    );\n    console.log(\"Video segments fetched.\", videoSegments);\n\n    console.log(\"Saving video segments...\");\n    for (let i = 0; i < videoSegments.length; i++) {\n      const segmentName = `segment-${i}.ts`;\n      const segmentHandle = await videoSegmentsDir.getFileHandle(segmentName, {\n        create: true,\n      });\n      saveAsset({\n        data: videoSegments[i],\n        handle: segmentHandle,\n      });\n    }\n    console.log(\"Video segments saved.\");\n\n    if (subtitleCode) {\n      if (videoData.subtitles.length > 0) {\n        console.log(\"Fetching subtitles...\");\n        const subtitle = videoData.subtitles.find(\n          (subtitle) => subtitle.code === subtitleCode\n        );\n        console.log(\"Subtitle fetched.\", subtitle);\n        if (subtitle) {\n          console.log(\"Converting subtitles...\");\n          const subs = await ttml2srt(subtitle.url, null);\n          console.log(\"Subtitles converted.\", subs);\n          console.log(\"Saving subtitles...\");\n          const subtitleHandle = await videoDir.getFileHandle(\n            `${subtitle.code}.srt`,\n            { create: true }\n          );\n          saveAsset({\n            data: subs,\n            handle: subtitleHandle,\n          });\n          console.log(\"Subtitles saved.\");\n        }\n      }\n    }\n    console.log(\"Fetching thumbnail...\");\n    const thumbnail = await fetchAssetData(\n      (url) => {\n        return retry(async () => {\n          return await fetchBlob(url);\n        }, 3);\n      },\n      {\n        url: videoData.thumbnailUrl,\n      }\n    );\n    console.log(\"Thumbnail fetched.\", thumbnail);\n    console.log(\"Saving thumbnail...\");\n    const thumbnailHandle = await videoDir.getFileHandle(\"thumbnail\", {\n      create: true,\n    });\n    saveAsset({\n      data: thumbnail,\n      handle: thumbnailHandle,\n    });\n    console.log(\"Thumbnail saved.\");\n\n    console.log(\"Fetching channel logo...\");\n    const channelIcon = await fetchAssetData(\n      (url) => {\n        return retry(async () => {\n          return await fetchBlob(url);\n        }, 3);\n      },\n      {\n        url: videoData.thumbnailUrl,\n      }\n    );\n    console.log(\"Channel logo fetched.\", channelIcon);\n    console.log(\"Saving channel logo...\");\n    const channelIconHandle = await videoDir.getFileHandle(\"channel-icon\", {\n      create: true,\n    });\n    saveAsset({\n      data: channelIcon,\n      handle: channelIconHandle,\n    });\n    console.log(\"Channel logo saved.\");\n\n    console.log(\"Fetching preview frames...\");\n    const previewFramesDir = await videoDir.getDirectoryHandle(\n      `preview-frames`,\n      {\n        create: true,\n      }\n    );\n    let index = 0;\n    for (const url of videoData.previewFrames[1].urls) {\n      const frame = await fetchAssetData(\n        (url) => {\n          return retry(async () => {\n            return await fetchBlob(url);\n          }, 3);\n        },\n        {\n          url,\n        }\n      );\n      console.log(`Getting file handle: preview-frame-${url.split(\"/\").pop()}`);\n      const frameHandle = await previewFramesDir.getFileHandle(`${index}`, {\n        create: true,\n      });\n      console.log(\"Saving preview frame...\", frame);\n      saveAsset({\n        data: frame,\n        handle: frameHandle,\n      });\n      index++;\n      console.log(\"Preview frame saved.\");\n    }\n\n    const downloaded = JSON.parse(localStorage.getItem(\"downloaded\") || \"[]\");\n    downloaded.push(videoId);\n    localStorage.setItem(\"downloaded\", JSON.stringify(downloaded));\n  } catch (error) {\n    console.error(\"Error downloading the video:\", error);\n    throw error;\n  }\n}\n\n/**\n * Reads a manifest file and returns its content as an array of lines.\n *\n * @param directory - Directory handle containing the manifest file.\n * @param manifestFile - Name of the manifest file.\n * @returns An array containing lines of the manifest file.\n */\nconst readManifestFileFromDirectory = async (\n  directory: any,\n  manifestFile: string\n) => {\n  console.log(\"Reading manifest file...\");\n  const fileHandle = await directory.getFileHandle(manifestFile);\n  const file = await fileHandle.getFile();\n  console.log(\"Manifest file read.\");\n  return (await file.text()).split(\"\\n\");\n};\n\n/**\n * Generates HLS content with the segments replaced.\n *\n * @param directory - Directory handle containing the segment files.\n * @param manifestContent - An array containing lines of the manifest file.\n * @returns A Blob URL containing the processed HLS content.\n */\nconst rebuildManifest = async (directory: any, manifestContent: string[]) => {\n  console.log(\"Rebuilding manifest...\", directory, manifestContent);\n  let content = \"\";\n  let segmentIndex = 0;\n  for (let line of manifestContent) {\n    console.log(\"Processing line...\", line);\n    if (line.includes(\"{segment}\")) {\n      const segmentFileHandle = await directory.getFileHandle(\n        `segment-${segmentIndex}.ts`\n      );\n      console.log(\"Getting segment file...\", segmentFileHandle);\n      const segmentFile = await segmentFileHandle.getFile();\n      const segmentUrl = URL.createObjectURL(segmentFile);\n      line = line.replace(\"{segment}\", segmentUrl);\n      segmentIndex++;\n    }\n    content += `${line}\\n`;\n  }\n  console.log(\"Manifest rebuilt.\", content);\n  return URL.createObjectURL(new Blob([content]));\n};\n\n/**\n * Generates an HLS manifest for a given video.\n *\n * @param videoId - The video ID.\n * @returns A Blob URL pointing to the HLS manifest.\n */\nexport async function getHlsManifest(videoId: string) {\n  console.time(\"manifest generating\");\n\n  console.log(\"Getting video data...\");\n  const storageRoot = await navigator.storage.getDirectory();\n  const videoDirectory = await storageRoot.getDirectoryHandle(videoId, {\n    create: false,\n  });\n\n  console.log(\"Reading video manifest...\");\n  const audioDirectory = await videoDirectory.getDirectoryHandle(\"audio\");\n  const videoDirectoryHandle = await videoDirectory.getDirectoryHandle(\"video\");\n\n  const audioManifestContent = await readManifestFileFromDirectory(\n    audioDirectory,\n    \"audio.m3u8\"\n  );\n  const videoManifestContent = await readManifestFileFromDirectory(\n    videoDirectoryHandle,\n    \"video.m3u8\"\n  );\n\n  console.log(\"Rebuilding audio manifest...\", audioManifestContent);\n  const audioContentUrl = await rebuildManifest(\n    audioDirectory,\n    audioManifestContent\n  );\n\n  console.log(\"Rebuilding video manifest...\", videoManifestContent);\n  const videoContentUrl = await rebuildManifest(\n    videoDirectoryHandle,\n    videoManifestContent\n  );\n\n  console.log(\"Generating master manifest...\");\n  const indexManifestHandle = await videoDirectory.getFileHandle(\"index.m3u8\");\n  console.log(\"master manifest handle\", indexManifestHandle);\n  const indexFile = await indexManifestHandle.getFile();\n  console.log(\"master manifest file\", indexFile);\n  const indexContent = (await indexFile.text())\n    .replace(\"{audio}\", audioContentUrl)\n    .replace(\"{video}\", videoContentUrl);\n  console.log(\"master manifest content\", indexContent);\n\n  console.timeEnd(\"manifest generating\");\n\n  return URL.createObjectURL(new Blob([indexContent]));\n}\n\nexport const getStreams = async (videoId: string) => {\n  console.log(\"Getting streams...\");\n  const storageRoot = await navigator.storage.getDirectory();\n  console.log(\"Storage root:\", storageRoot);\n  const videoDirectory = await storageRoot.getDirectoryHandle(videoId, {\n    create: false,\n  });\n  console.log(\"Video directory:\", videoDirectory);\n  if (!videoDirectory) {\n    return null;\n  }\n  const streamsFileHandle = await videoDirectory.getFileHandle(\"streams.json\");\n  const streamsFile = await streamsFileHandle.getFile();\n  console.log(\"Streams file:\", streamsFile);\n\n  const text = await streamsFile.text();\n  const streams = JSON.parse(text);\n  console.log(\"Streams:\", streams);\n  if (!streams) throw new Error(\"Streams not found\");\n  const thumbnailFileHandle = await videoDirectory.getFileHandle(\"thumbnail\");\n  const thumbnailFile = await thumbnailFileHandle.getFile();\n  const thumbnailUrl = URL.createObjectURL(thumbnailFile);\n  console.log(\"Thumbnail URL:\", thumbnailUrl);\n\n  const channelIconFileHandle = await videoDirectory.getFileHandle(\n    \"channel-icon\"\n  );\n  console.log(\"Channel icon file handle:\", channelIconFileHandle);\n  const channelIconFile = await channelIconFileHandle.getFile();\n  const channelIconUrl = URL.createObjectURL(channelIconFile);\n\n  console.log(\"Channel icon URL:\", channelIconUrl);\n  const subtitles = [];\n  streams.thumbnailUrl = thumbnailUrl;\n  streams.uploaderAvatar = channelIconUrl;\n  try {\n    const subtitlesDirectory = await videoDirectory.getDirectoryHandle(\n      `subtitles`,\n      {\n        create: false,\n      }\n    );\n    console.log(\"Subtitles directory:\", subtitlesDirectory);\n    for (const code of streams.subtitles) {\n      const subtitleFileHandle = await subtitlesDirectory.getFileHandle(\n        `${code}.srt`\n      );\n      const subtitleFile = await subtitleFileHandle.getFile();\n      const subtitleUrl = URL.createObjectURL(subtitleFile);\n      subtitles.push({\n        code,\n        url: subtitleUrl,\n      });\n    }\n  } catch (error) {\n    console.log(\"Error getting subtitles:\", error);\n  }\n\n  if (subtitles.length > 0) {\n    streams.subtitles = subtitles;\n  }\n  console.log(\"Getting preview frames...\");\n  let previewFramesDirectory;\n\n  try {\n    previewFramesDirectory = await videoDirectory.getDirectoryHandle(\n      `preview-frames`,\n      {\n        create: false,\n      }\n    );\n  } catch (error) {\n    console.log(\"Error getting preview frames:\", error);\n  }\n  console.log(\"Preview frames directory:\", previewFramesDirectory);\n  const urls = [];\n  let index = 0;\n  if (previewFramesDirectory) {\n    try {\n      for (const frameUrl of streams.previewFrames[1].urls) {\n        const frameFileHandle = await previewFramesDirectory.getFileHandle(\n          `${index}`\n        );\n        const frameFile = await frameFileHandle.getFile();\n        const frameUrl = URL.createObjectURL(frameFile);\n        urls.push(frameUrl);\n        index++;\n      }\n    } catch (error) {\n      console.log(\"Error getting preview frames:\", error);\n    }\n  }\n  console.log(\"Preview frames URLs:\", urls);\n  streams.previewFrames[1].urls = urls;\n  console.log(\"Streams:\", streams);\n\n  return streams;\n};\n","import { createQuery, isServer } from \"@tanstack/solid-query\";\nimport {\n  createEffect,\n  createSignal,\n  For,\n  Match,\n  Show,\n  Suspense,\n  Switch,\n} from \"solid-js\";\nimport { usePreferences } from \"~/stores/preferencesStore\";\nimport { RelatedPlaylist } from \"~/types\";\nimport api from \"~/utils/api\";\nimport { useSyncStore } from \"~/stores/syncStore\";\nimport VideoCard from \"./content/stream/VideoCard\";\nimport PlaylistCard from \"./content/playlist/PlaylistCard\";\nimport { useSearchParams } from \"@solidjs/router\";\n\nexport default function RelatedVideos() {\n  const [v, setV] = createSignal<string | undefined>(undefined);\n  const [preferences] = usePreferences();\n  const [searchParams] = useSearchParams();\n  createEffect(() => {\n    if (!searchParams.v) return;\n    setV(searchParams.v);\n  });\n  const sync = useSyncStore();\n\n  const videoQuery = createQuery(() => ({\n    queryKey: [\"streams\", v(), preferences.instance.api_url],\n    queryFn: () => api.fetchVideo(v(), preferences.instance.api_url),\n    enabled: v() && preferences.instance.api_url ? true : false,\n    refetchOnReconnect: false,\n    refetchOnMount: false,\n    cacheTime: Infinity,\n    staleTime: 100 * 60 * 1000,\n    deferStream: true,\n  }));\n  return (\n    <Show\n      when={videoQuery.data}\n      fallback={<For each={Array(20).fill(0)}>{() => <VideoCard />}</For>}\n    >\n      <div class=\"w-full max-w-max md:max-w-min\">\n        <For\n          each={videoQuery.data?.relatedStreams\n            // blocklist\n            .filter(\n              (item) =>\n                !sync.store.blocklist[item?.uploaderUrl?.split(\"/\").pop()!]\n            )}\n        >\n          {(stream) => {\n            return (\n              <Switch>\n                <Match when={stream.type === \"stream\"}>\n                  <VideoCard v={stream} layout=\"sm:grid\" />\n                </Match>\n                <Match when={stream.type === \"playlist\"}>\n                  <PlaylistCard item={stream as unknown as RelatedPlaylist} />\n                </Match>\n              </Switch>\n            );\n          }}\n        </For>\n      </div>\n    </Show>\n  );\n}\n","import { Dynamic, Portal } from \"solid-js/web\";\nimport {\n  Component,\n  createEffect,\n  createSignal,\n  JSX,\n  onCleanup,\n  onMount,\n} from \"solid-js\";\n\nconst DEFAULT_THRESHOLD = 50;\nconst VELOCITY_THRESHOLD = 0.5; // Units: pixels/ms\n\n\nexport interface BaseSolidBottomsheetProps {\n  children: JSX.Element;\n  onClose: () => void;\n  onIntersect?: () => void;\n}\n\nexport interface DefaultVariantProps extends BaseSolidBottomsheetProps {\n  variant: \"default\";\n}\n\nexport interface SnapVariantProps extends BaseSolidBottomsheetProps {\n  variant: \"snap\";\n  defaultSnapPoint: ({ maxHeight }: { maxHeight: number }) => number;\n  snapPoints: ({ maxHeight }: { maxHeight: number }) => number[];\n}\n\nexport type SolidBottomsheetProps = DefaultVariantProps | SnapVariantProps;\n\nexport const Bottomsheet: Component<SolidBottomsheetProps> = (props) => {\n  const isSnapVariant = props.variant === \"snap\";\n\n  const [maxHeight, setMaxHeight] = createSignal(window.visualViewport!.height);\n  const [isClosing, setIsClosing] = createSignal(false);\n  const [isSnapping, setIsSnapping] = createSignal(false);\n\n  const getDefaultTranslateValue = () => {\n    if (isSnapVariant) {\n      const defaultValue = props.defaultSnapPoint({ maxHeight: maxHeight() });\n      if (defaultValue !== maxHeight()) {\n        return window.innerHeight - defaultValue;\n      }\n    }\n    return 0;\n  };\n\n  const getSnapPoints = (maxHeight: number): number[] => {\n    return isSnapVariant\n      ? [0, ...props.snapPoints({ maxHeight }).sort((a, b) => b - a)]\n      : [];\n  };\n\n  const clampInRange = ({\n    minimum,\n    maximum,\n    current,\n  }: Record<\"minimum\" | \"maximum\" | \"current\", number>): number =>\n    Math.min(Math.max(current, minimum), maximum);\n\n  const [bottomsheetTranslateValue, setBottomsheetTranslateValue] =\n    createSignal(getDefaultTranslateValue());\n\n  const onViewportChange = () => {\n    setMaxHeight(window.visualViewport!.height);\n  };\n\n  onMount(() => {\n    // document.body.classList.add(\"overflow-hidden\");\n    window.visualViewport!.addEventListener(\"resize\", onViewportChange);\n  });\n\n  onCleanup(() => {\n    // document.body.classList.remove(\"overflow-hidden\");\n    window.visualViewport!.removeEventListener(\"resize\", onViewportChange);\n  });\n\n  createEffect(() => {\n    snapPoints = getSnapPoints(maxHeight());\n  });\n\n  let snapPoints: number[] = [];\n\n  let touchStartPosition = 0;\n  let lastTouchPosition = 0;\n  const acceptIds = new Set<string>([\"sb-handle\", \"sb-content\"]);\n\n  let lastTouchTime = 0;\n  let velocityY = 0;\n\n  const onTouchStart: JSX.EventHandlerUnion<HTMLDivElement, TouchEvent> = (\n    event\n  ) => {\n    if (!acceptIds.has(event.target.id) && !isEventFromContentChildren(event)) {\n      return;\n    }\n    lastTouchTime = event.timeStamp;\n    isSnapVariant && setIsSnapping(false);\n\n    touchStartPosition = lastTouchPosition = event.touches[0].clientY;\n    event.preventDefault();\n    event.stopPropagation();\n  };\n  const [contentScrollTop, setContentScrollTop] = createSignal(1);\n  const [isInitialTouch, setIsInitialTouch] = createSignal(true);\n\n  const onTouchMoveHandle: JSX.EventHandlerUnion<HTMLDivElement, TouchEvent> = (\n    event\n  ) => {\n    if (event.target.id !== \"sb-handle\") return;\n    event.preventDefault();\n    let dragDistance = 0;\n    const currentTime = event.timeStamp;\n    const timeDelta = currentTime - lastTouchTime;\n    if (timeDelta > 0) {\n      // Calculate velocity in pixels per millisecond\n      velocityY = dragDistance / timeDelta;\n    }\n    lastTouchTime = currentTime;\n\n    switch (props.variant) {\n      case \"snap\":\n        dragDistance = event.touches[0].clientY - lastTouchPosition;\n\n        setBottomsheetTranslateValue((previousVal) =>\n          clampInRange({\n            minimum: 0,\n            maximum: maxHeight(),\n            current: previousVal + dragDistance,\n          })\n        );\n\n        lastTouchPosition = event.touches[0].clientY;\n\n        break;\n      case \"default\":\n      default:\n        lastTouchPosition = event.touches[0].clientY;\n        dragDistance = lastTouchPosition - touchStartPosition;\n\n        if (dragDistance > 0) {\n          setBottomsheetTranslateValue(dragDistance);\n        }\n\n        break;\n    }\n  };\n\n  const onTouchMoveContent: JSX.EventHandlerUnion<\n    HTMLDivElement,\n    TouchEvent\n  > = (event) => {\n    if (!isEventFromContentChildren(event)) return;\n    console.log(\"onTouchMoveContent\", contentScrollTop());\n    if (contentScrollTop() > 5) return;\n    let dragDistance = 0;\n    const currentTime = event.timeStamp;\n    lastTouchTime = currentTime;\n\n    switch (props.variant) {\n      case \"snap\":\n        dragDistance = event.touches[0].clientY - lastTouchPosition;\n\n        setBottomsheetTranslateValue((previousVal) =>\n          clampInRange({\n            minimum: 0,\n            maximum: maxHeight(),\n            current: previousVal + dragDistance,\n          })\n        );\n\n        lastTouchPosition = event.touches[0].clientY;\n\n        break;\n      case \"default\":\n      default:\n        lastTouchPosition = event.touches[0].clientY;\n        dragDistance = lastTouchPosition - touchStartPosition;\n\n        if (dragDistance > 0) {\n          setBottomsheetTranslateValue(dragDistance);\n        }\n\n        break;\n    }\n  };\n  async function wait(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  const isInertialScrolling = async (lastScrollTop: number) => {\n    await wait(100);\n    return new Promise((resolve) => {\n      if (lastScrollTop === contentScrollTop()) {\n        resolve(false);\n      } else {\n        resolve(true);\n      }\n    });\n  };\n\n  const onTouchEnd: JSX.EventHandlerUnion<HTMLDivElement, TouchEvent> = async (\n    event\n  ) => {\n    if (!acceptIds.has(event.target.id) && !isEventFromContentChildren(event)) {\n      return;\n    }\n    let currentPoint = 0;\n    let closestPoint = 0;\n    const swipeDuration = event.timeStamp - lastTouchTime;\n    const swipeDistance = lastTouchPosition - touchStartPosition;\n    const swipeVelocity = -swipeDistance / swipeDuration;\n    console.log(\"swipeVelocity\", swipeVelocity, velocityY);\n\n    switch (props.variant) {\n      case \"snap\":\n        if (event.target.id !== \"sb-handle\") {\n          if (await isInertialScrolling(contentScrollTop())) {\n            console.log(\"isInertialScrolling\");\n            return;\n          }\n          setContentScrollTop(Math.max(0, contentScrollTop() - 1));\n          if (contentScrollTop() > 5) {\n            console.log(\"contentScrollTop\", contentScrollTop());\n            return;\n          }\n        }\n        // Decide to snap or close based on the swipe velocity as well as the distance\n        if (Math.abs(swipeVelocity) > VELOCITY_THRESHOLD || Math.abs(swipeDistance) > DEFAULT_THRESHOLD) {\n          // If the swipe is quick or long enough, determine the closest snap point or closing\n          currentPoint = (maxHeight() - lastTouchPosition) + (swipeVelocity * 2)\n\n          // Use velocity to determine if we should adjust our snap point\n          closestPoint = snapPoints.reduce((previousVal, currentVal) => {\n            return Math.abs(currentVal - currentPoint) <\n              Math.abs(previousVal - currentPoint)\n              ? currentVal\n              : previousVal;\n          });\n\n        } else {\n          currentPoint = maxHeight() - bottomsheetTranslateValue();\n          closestPoint = snapPoints.reduce((previousVal, currentVal) => {\n            return Math.abs(currentVal - currentPoint) <\n              Math.abs(previousVal - currentPoint)\n              ? currentVal\n              : previousVal;\n          }\n          );\n        }\n\n        if (closestPoint === 0) {\n          setIsClosing(true);\n        }\n\n        setIsSnapping(true);\n        setBottomsheetTranslateValue(maxHeight() - closestPoint);\n\n        break;\n      case \"default\":\n      default:\n        if (lastTouchPosition - touchStartPosition > DEFAULT_THRESHOLD) {\n          setIsClosing(true);\n        } else {\n          setBottomsheetTranslateValue(0);\n        }\n\n        break;\n    }\n  };\n\n  const isEventFromContentChildren = (\n    event: TouchEvent | MouseEvent\n  ): boolean => {\n    let target: EventTarget | null = event.target;\n\n    while (target) {\n      if ((target as HTMLElement).id === \"sb-content\") {\n        return true;\n      }\n\n      target = (target as HTMLElement).parentElement;\n    }\n\n    return false;\n  };\n\n  let sbHandle!: HTMLDivElement\n  onMount(() => {\n    const options = { passive: false };\n    sbHandle.addEventListener(\"touchstart\", onTouchStart as any, options);\n    sbHandle.addEventListener(\"touchmove\", onTouchMoveHandle as any, options);\n    sbHandle.addEventListener(\"touchend\", onTouchEnd as any, options);\n    sbHandle.addEventListener(\"touchcancel\", onTouchEnd as any, options);\n\n    onCleanup(() => {\n      sbHandle.removeEventListener(\"touchstart\", onTouchStart as any);\n      sbHandle.removeEventListener(\"touchmove\", onTouchMoveHandle as any);\n      sbHandle.removeEventListener(\"touchend\", onTouchEnd as any);\n      sbHandle.removeEventListener(\"touchcancel\", onTouchEnd as any);\n    });\n  });\n\n  return (\n    <Portal>\n      <div\n        id=\"sb-overlay\"\n        class=\"fixed inset-0 flex items-end pointer-events-none z-[999999]\"\n      >\n        <div\n          classList={{\n            \"w-full bg-bg1 pointer-events-auto\": true,\n            \"animate-out slide-out-to-bottom duration-500\": isClosing(),\n            \"animate-in slide-in-from-bottom \": !isClosing(),\n            \"transition-all duration-250\": isSnapping(),\n          }}\n          style={{\n            transform: `translateY(${bottomsheetTranslateValue()}px)`,\n            ...(isSnapVariant ? { height: `${maxHeight()}px` } : {}),\n          }}\n          {...(isClosing() ? { onAnimationEnd: props.onClose } : {})}\n        >\n          <div\n            id=\"sb-handle\"\n            class=\"py-5 my-0 mx-auto bg-bg1\"\n            ref={sbHandle}\n\n          >\n            <div class=\"w-10 h-1 m-auto bg-bg3 pointer-events-none\" />\n          </div>\n          <div\n            id=\"sb-content\"\n            class=\"relative w-full h-full bg-bg1 overscroll-contain\"\n            classList={{\n              \"overflow-y-auto\": true,\n            }}\n            style={{\n              height: `calc(100vh - ${bottomsheetTranslateValue()}px)`,\n            }}\n            onScroll={(e) => {\n              setContentScrollTop(e.currentTarget.scrollTop + 1);\n            }}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMoveContent}\n            onTouchEnd={onTouchEnd}\n          >\n            {props.children}\n          </div>\n        </div>\n      </div>\n    </Portal>\n  );\n};\n","// TODO: Pinned, verified, hearted\nimport { createInfiniteQuery } from \"@tanstack/solid-query\";\nimport { FaSolidThumbsUp } from \"solid-icons/fa\";\nimport { Show, createSignal, useContext, Suspense, For, createEffect } from \"solid-js\";\nimport { usePreferences } from \"~/stores/preferencesStore\";\nimport { useSyncStore } from \"~/stores/syncStore\";\nimport { fetchJson } from \"~/utils/helpers\";\nimport { sanitizeText } from \"./Description\";\nimport Link from \"./Link\";\nexport interface PipedCommentResponse {\n  comments: PipedComment[];\n  disabled: boolean;\n  nextpage: string;\n}\n\nexport interface PipedComment {\n  author: string;\n  thumbnail: string;\n  commentId: string;\n  commentText: string;\n  commentedTime: string;\n  commentorUrl: string;\n  repliesPage?: string;\n  likeCount: number;\n  replyCount: number;\n  hearted: boolean;\n  pinned: boolean;\n  verified: boolean;\n}\n\ninterface Props {\n  videoId: string;\n  comment: PipedComment;\n  nextpage: string;\n  uploader: string;\n}\nexport default function Comment(props: Props) {\n  const [loadingReplies, setLoadingReplies] = createSignal(false);\n  const [showingReplies, setShowingReplies] = createSignal(false);\n  const [replies, setReplies] = createSignal([]);\n  const [nextpage, setNextpage] = createSignal(null);\n  const store = useSyncStore();\n  const [preferences] = usePreferences();\n  const fetchComments = async ({\n    pageParam = \"initial\",\n  }): Promise<PipedCommentResponse> => {\n    if (pageParam === \"initial\") {\n      return await fetchJson(\n        `${preferences.instance.api_url}/nextpage/comments/${props.videoId}`,\n        {\n          nextpage: props.comment.repliesPage!,\n        }\n      );\n    } else {\n      return await fetchJson(\n        `${preferences.instance.api_url}/nextpage/comments/${props.videoId}`,\n        {\n          nextpage: pageParam,\n        }\n      );\n    }\n  };\n\n  const query = createInfiniteQuery(() => ({\n    queryKey: [\n      \"commentsReplies\",\n      props.videoId,\n      preferences.instance.api_url,\n      props.comment.commentId,\n    ],\n    queryFn: fetchComments,\n    enabled: preferences.instance?.api_url &&\n      props.videoId &&\n      props.comment.repliesPage &&\n      showingReplies()\n      ? true\n      : false,\n    getNextPageParam: (lastPage) => {\n      return lastPage.nextpage;\n    },\n    initialPageParam: \"initial\"\n  })\n  );\n  async function hideReplies() {\n    setShowingReplies(false);\n  }\n\n  const [sanitizedText, setSanitizedText] = createSignal(\"\");\n  createEffect(async () => {\n    setSanitizedText(await sanitizeText(props.comment.commentText));\n  });\n\n  return (\n    <>\n      <div class=\"flex  gap-2 \">\n        <Link\n          href={`${props.comment.commentorUrl}`}\n          class=\"w-1/12 rounded-full justify-center flex h-fit\"\n        >\n          <img\n            width=\"48\"\n            height=\"48\"\n            src={props.comment.thumbnail}\n            alt=\"\"\n            class=\"rounded-full w-full h-full\"\n          />\n        </Link>\n        <div class=\"flex flex-col  w-11/12\">\n          <span class=\"flex gap-2 items-center\">\n            <Link\n              href={`${props.comment.commentorUrl}`}\n              class={`text-sm font-bold ${props.comment.commentorUrl === props.uploader &&\n                \"bg-background rounded-full px-4\"\n                }`}\n            >\n              {props.comment.author}\n            </Link>\n            {props.comment.verified && (\n              <svg\n                class=\"w-4 h-4\"\n                viewBox=\"0 0 24 24\"\n                fill=\"currentColor\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n              >\n                <path\n                  fill-rule=\"evenodd\"\n                  clip-rule=\"evenodd\"\n                  d=\"M12.0001 2.00001C6.47715 2.00001 2.00006 6.4771 2.00006 12C2.00006 17.5229 6.47715 22 12.0001 22C17.5229 22 22 17.5229 22 12C22 6.4771 17.5229 2.00001 12.0001 2.00001ZM12.0001 4.00001C16.4182 4.00001 20.0001 7.58191 20.0001 12C20.0001 16.4181 16.4182 20 12.0001 20C7.58199 20 4.00006 16.4181 4.00006 12C4.00006 7.58191 7.58199 4.00001 12.0001 4.00001ZM11.9999 7.00001C11.4477 7.00001 10.9999 7.44772 10.9999 8.00001V12.0001L8.99994 12.0001C8.44775 12.0001 7.99994 12.4478 7.99994 13.0001C7.99994 13.5523 8.44775 14.0001 8.99994 14.0001L11.9999 14.0001V18.0001C11.9999 18.5523 12.4477 19.0001 12.9999 19.0001C13.5521 19.0001 13.9999 18.5523 13.9999 18.0001V8.00001C13.9999 7.44772 13.5521 7.00001 11.9999 7.00001Z\"\n                />\n              </svg>\n            )}\n            <p class=\"text-xs text-text2\">{props.comment.commentedTime}</p>\n          </span>\n          <Suspense fallback={<p>Loading...</p>}>\n            <p\n              class=\"text-xs\"\n              innerHTML={sanitizedText()}\n            ></p>\n          </Suspense>\n          <span class=\"flex gap-1 items-center text-xs \">\n            <FaSolidThumbsUp />\n            {props.comment.likeCount}\n            <Show when={props.comment.replyCount > 0 && !showingReplies()}>\n              {props.comment.replyCount > 1 && (\n                <button\n                  onClick={() => setShowingReplies(true)}\n                  class=\"underline\"\n                >\n                  View {props.comment.replyCount} replies\n                </button>\n              )}\n              {props.comment.replyCount === 1 && (\n                <button\n                  onClick={() => setShowingReplies(true)}\n                  class=\"underline\"\n                >\n                  View 1 reply\n                </button>\n              )}\n            </Show>\n            <Show when={showingReplies()}>\n              <button\n                onClick={() => setShowingReplies(false)}\n                class=\"underline\"\n              >\n                Hide replies\n              </button>\n            </Show>\n          </span>\n        </div>\n      </div>\n      <Show when={showingReplies()}>\n        <div class=\"ml-8 my-2\">\n          <Suspense fallback={<div class=\"text-xs\">Loading...</div>}>\n            <For\n              each={query.data?.pages\n                ?.flat()\n                ?.map((page) => page.comments)\n                .flat()}\n            >\n              {(comment) => (\n                <Comment\n                  comment={comment}\n                  uploader={props.uploader}\n                  videoId={props.videoId}\n                  nextpage={\"\"}\n                />\n              )}\n            </For>\n            <Show when={query.hasNextPage}>\n              <button\n                onClick={() => query.fetchNextPage()}\n                class=\"text-xs underline\"\n              >\n                Load more replies\n              </button>\n            </Show>\n          </Suspense>\n        </div>\n      </Show>\n    </>\n  );\n}\n","import { createInfiniteQuery } from \"@tanstack/solid-query\";\nimport { createEffect, createSignal, Match, onCleanup, onMount, Show, Suspense, Switch } from \"solid-js\";\nimport { For } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport useIntersectionObserver from \"~/hooks/useIntersectionObserver\";\nimport { usePreferences } from \"~/stores/preferencesStore\";\nimport { fetchJson, isMobile } from \"~/utils/helpers\";\nimport { Bottomsheet } from \"./Bottomsheet\";\nimport Comment, { PipedCommentResponse } from \"./Comment\";\n\nexport default function Comments(props: {\n  videoId: string; uploader: string;\n  display: \"default\" | \"bottomsheet\"\n}) {\n  const [preferences] = usePreferences();\n  const fetchComments = async ({\n    pageParam = \"initial\",\n  }): Promise<PipedCommentResponse> => {\n    if (pageParam === \"initial\") {\n      return await (\n        await fetch(`${preferences.instance.api_url}/comments/${props.videoId}`)\n      ).json();\n    } else {\n      return await fetchJson(\n        `${preferences.instance.api_url}/nextpage/comments/${props.videoId}`,\n        {\n          nextpage: pageParam,\n        }\n      );\n    }\n  };\n  const [playerHeight, setPlayerHeight] = createSignal(0);\n  createEffect(() => {\n    const player = document.querySelector(\"media-player\");\n    if (player) {\n      setPlayerHeight(player.clientHeight + 50);\n    }\n  });\n\n  const query = createInfiniteQuery(() => ({\n    queryKey: [\"comments\", props.videoId, preferences.instance.api_url],\n    queryFn: fetchComments,\n    enabled: (preferences.instance?.api_url && props.videoId) ? true : false,\n    getNextPageParam: (lastPage) => {\n      return lastPage.nextpage;\n    },\n    initialPageParam: \"initial\",\n  })\n  );\n  const [commentsOpen, setCommentsOpen] = createSignal(false);\n  const [intersectionRef, setIntersectionRef] = createSignal<\n    HTMLDivElement | undefined\n  >(undefined);\n\n  const isIntersecting = useIntersectionObserver({\n    setTarget: () => intersectionRef(),\n  });\n\n  createEffect(() => {\n    if (isIntersecting()) {\n      if (query.hasNextPage) {\n        query.fetchNextPage();\n      }\n    }\n  });\n\n\n  return (\n    <>\n      <Switch>\n        <Match when={props.display === \"bottomsheet\"}>\n          <button\n            class=\"text-center text-sm w-full rounded-lg bg-bg2 p-2 mb-2\"\n            onClick={() => setCommentsOpen(true)}\n          >\n            Comments\n          </button>\n          {commentsOpen() && (\n            <Bottomsheet\n              variant=\"snap\"\n              defaultSnapPoint={({ maxHeight }) => maxHeight - playerHeight() ?? 300}\n              snapPoints={({ maxHeight }) => [maxHeight - 40, maxHeight - playerHeight() ?? 300]}\n              onClose={() => {\n                console.log(\"close\");\n                setCommentsOpen(false);\n              }}\n            >\n              {/* <div class=\"text-text1 bg-bg1 p-2 rounded-t-lg max-h-full max-w-full overflow-auto\"> */}\n              <Suspense fallback={<p>Loading...</p>}>\n                <div id=\"sb-content\" class=\"flex flex-col gap-1 relative z-50 \">\n                  <Show when={query.data}>\n                    <For each={query.data!.pages}>\n                      {(page) => (\n                        <For each={page.comments\n                          .filter((c) => c.commentText)\n                        }>\n                          {(comment) => (\n                            <Comment\n                              videoId={props.videoId}\n                              comment={comment}\n                              uploader={props.uploader}\n                              nextpage={\"\"}\n                            />\n                          )}\n                        </For>\n                      )}\n                    </For>\n                    <div\n                      class=\"w-full h-40 bg-primary\"\n                      ref={(ref) => setIntersectionRef(ref)}\n                    />\n                  </Show>\n                </div>\n              </Suspense>\n              {/* </div> */}\n            </Bottomsheet>\n          )}\n        </Match>\n        <Match when={props.display === \"default\"}>\n          <div class=\"text-text1 bg-bg1 p-2 rounded-t-lg max-w-full overflow-y-auto \">\n            <Suspense fallback={<p>Loading...</p>}>\n              <div id=\"sb-content\" class=\"flex flex-col gap-1 relative  \">\n                <Show when={query.data}>\n                  <For each={query.data!.pages}>\n                    {(page) => (\n                      <For each={page.comments\n                          .filter((c) => c.commentText)\n                      }>\n                        {(comment) => (\n                          <Comment\n                            videoId={props.videoId}\n                            comment={comment}\n                            uploader={props.uploader}\n                            nextpage={\"\"}\n                          />\n                        )}\n                      </For>\n                    )}\n                  </For>\n                  <div\n                    class=\"w-full h-40 bg-primary\"\n                    ref={(ref) => setIntersectionRef(ref)}\n                  />\n                </Show>\n              </div>\n            </Suspense>\n          </div>\n        </Match>\n      </Switch>\n    </>\n  );\n}\n","// TODO: Integrate offline playback\nimport Description from \"~/components/Description\";\nimport {\n  Show,\n  createEffect,\n  createSignal,\n  onMount,\n  untrack,\n  useContext,\n  Switch,\n  Match,\n  onCleanup,\n} from \"solid-js\";\nimport { For } from \"solid-js\";\nimport { getHlsManifest, getStreams } from \"~/utils/hls\";\nimport { usePlaylist } from \"~/stores/playlistStore\";\nimport { useSyncStore } from \"~/stores/syncStore\";\nimport { useAppState } from \"~/stores/appStateStore\";\nimport { createQuery } from \"@tanstack/solid-query\";\nimport { Chapter, PipedVideo, RelatedPlaylist } from \"~/types\";\nimport { usePreferences } from \"~/stores/preferencesStore\";\nimport { Suspense } from \"solid-js\";\nimport numeral from \"numeral\";\nimport { isServer } from \"solid-js/web\";\nimport api from \"~/utils/api\";\nimport RelatedVideos from \"~/components/RelatedVideos\";\nimport Comments from \"~/components/Comments\";\nimport { getVideoId, isMobile } from \"~/utils/helpers\";\nimport PlaylistItem from \"~/components/content/playlist/PlaylistItem\";\nimport { useLocation, useSearchParams } from \"@solidjs/router\";\n\nexport interface SponsorSegment {\n  category: string;\n  actionType: string;\n  segment: number[];\n  UUID: string;\n  videoDuration: number;\n  locked: number;\n  votes: number;\n  description: string;\n}\n\nexport async function fetchWithTimeout(\n  resource: string,\n  options: RequestInit & { timeout: number } = { timeout: 800 }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => {\n    console.log(\"aborting\");\n    controller.abort(`Request exceeded timeout of ${timeout}ms.`);\n  }, timeout);\n  console.log(\"fetching\", controller.signal);\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal,\n  });\n  clearTimeout(id);\n\n  return response;\n}\n\nexport default function Watch() {\n  console.log(new Date().toISOString().split(\"T\")[1], \"rendering watch page\");\n\n  const route = useLocation();\n  const [preferences] = usePreferences();\n\n  const [v, setV] = createSignal<string | undefined>(undefined);\n  createEffect(() => {\n    if (!route.query.v) return;\n    setV(route.query.v);\n  });\n  const videoQuery = createQuery<any, any, PipedVideo>(() => ({\n    queryKey: [\"streams\", v(), preferences.instance.api_url],\n    queryFn: () => api.fetchVideo(v(), preferences.instance.api_url),\n    enabled: v() && preferences.instance.api_url ? true : false,\n    refetchOnReconnect: false,\n    refetchOnMount: false,\n    cacheTime: Infinity,\n    staleTime: 100 * 60 * 1000,\n    deferStream: true,\n  }));\n\n  const [playlist, setPlaylist] = usePlaylist();\n\n  const [videoDownloaded, setVideoDownloaded] = createSignal(true);\n  createEffect(async () => {\n    if (!route.query.v) return;\n    console.time(\"verifyDownloaded\");\n    if (!(\"getDirectory\" in navigator.storage)) {\n      setVideoDownloaded(false);\n      return;\n    }\n    try {\n      const downloaded = await getStreams(route.query.v);\n      console.log(\"downloaded\", downloaded);\n      if (downloaded) {\n        console.log(\"video downloaded\");\n        const manifest = await getHlsManifest(route.query.v);\n        console.log(\"manifest\", manifest);\n        // setVideo({\n        //   value: {\n        //     ...downloaded,\n        //     hls: manifest,\n        //   },\n        // });\n        // console.log(video.value, \"previewFrames\");\n        return;\n      } else {\n        console.log(\"video not downloaded\");\n        setVideoDownloaded(false);\n        console.timeEnd(\"verifyDownloaded\");\n      }\n    } catch (e) {\n      console.log(e);\n      setVideoDownloaded(false);\n      return;\n    }\n  });\n\n  const [appState, setAppState] = useAppState();\n  const sync = useSyncStore();\n  const isLocalPlaylist = () => route.query.list?.startsWith(\"conduit-\");\n  const sponsorsQuery = createQuery<SponsorSegment[]>(() => ({\n    queryKey: [\"sponsors\", route.query.v, preferences.instance.api_url],\n    queryFn: async (): Promise<SponsorSegment[]> => {\n      const sha256Encrypted = await globalThis.crypto.subtle.digest(\n        \"SHA-256\",\n        new TextEncoder().encode(route.query.v)\n      );\n      const sha256Array = Array.from(new Uint8Array(sha256Encrypted));\n      const prefix = sha256Array\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\")\n        .slice(0, 5);\n      const urlObj = new URL(\n        \"https://sponsor.ajay.app/api/skipSegments/\" + prefix\n      );\n      urlObj.searchParams.set(\n        \"categories\",\n        JSON.stringify([\n          \"sponsor\",\n          \"interaction\",\n          \"selfpromo\",\n          \"music_offtopic\",\n        ])\n      );\n      const url = urlObj.toString();\n      console.log(url);\n      const res = await fetch(url);\n      if (!res.ok) {\n        if (res.status === 404) {\n          return Promise.reject(\"no sponsors found\");\n        } else {\n          const text = await res.text();\n          return Promise.reject(\"error fetching sponsors: \" + text);\n        }\n      }\n      const data = await res.json();\n      const video = data.find((v: any) => v.videoID === route.query.v);\n      if (!video) {\n        return Promise.reject(\"no sponsors found\");\n      }\n      return video.segments;\n    },\n    enabled:\n      preferences.instance?.api_url && !isServer && route.query.v\n        ? true\n        : false,\n    refetchOnReconnect: false,\n    retry: false,\n    suspense: false,\n    useErrorBoundary: false,\n  }));\n  const playlistQuery = createQuery(() => ({\n    queryKey: [\"playlist\", route.query.list, preferences.instance.api_url],\n    queryFn: async () => {\n      const res = await fetch(\n        `${preferences.instance.api_url}/playlists/${route.query.list}`\n      );\n      if (!res.ok) {\n        // throw new Error(\"Failed to fetch playlist\");\n        return;\n      }\n      return await res.json();\n    },\n    enabled:\n      preferences.instance?.api_url && route.query.list && !isLocalPlaylist()\n        ? true\n        : false,\n    refetchOnReconnect: false,\n  }));\n  createEffect(() => {\n    console.log(sync.store, \"STORE\");\n    console.log(sponsorsQuery.data, sponsorsQuery.error);\n  });\n\n  createEffect(() => {\n    if (playlistQuery.isSuccess) {\n      setPlaylist(playlistQuery.data);\n    } else {\n      setPlaylist(undefined);\n    }\n  });\n\n  const mergeChaptersAndSponsors = (\n    chapters: Chapter[],\n    sponsors: SponsorSegment[]\n  ): Chapter[] => {\n    const sortedChapters = [...chapters].sort((a, b) => a.start - b.start);\n    const sortedSponsors = [...sponsors].sort(\n      (a, b) => a.segment[0] - b.segment[0]\n    );\n\n    const result: Chapter[] = [];\n\n    let chapterIndex = 0;\n    let sponsorIndex = 0;\n\n    while (\n      chapterIndex < sortedChapters.length ||\n      sponsorIndex < sortedSponsors.length\n    ) {\n      const currentChapter = sortedChapters[chapterIndex];\n      const currentSponsor = sortedSponsors[sponsorIndex];\n      const nextChapter = sortedChapters[chapterIndex];\n\n      const nextSegmentStart = nextChapter?.start ?? Number.MAX_SAFE_INTEGER;\n\n      if (\n        currentChapter &&\n        (!currentSponsor || currentChapter.start <= currentSponsor.segment[0])\n      ) {\n        result.push(currentChapter);\n        chapterIndex++;\n      } else if (currentSponsor) {\n        result.push({\n          title: `Sponsor: ${currentSponsor.category}`,\n          start: currentSponsor.segment[0],\n        } as Chapter);\n\n        if (Math.abs(nextSegmentStart - currentSponsor.segment[1]) >= 5) {\n          console.log(\n            \"Next chapter is more than 5s after end of sponsor, adding chapter. \",\n            \"next segment start is: \",\n            numeral(nextSegmentStart).format(\"00:00:00\"),\n            \"current sponsor end is: \",\n            numeral(currentSponsor.segment[1]).format(\"00:00:00\"),\n            \"absolute value is: \",\n            Math.abs(nextSegmentStart - currentSponsor.segment[1])\n          );\n          result.push({\n            title: `End Sponsor: ${currentSponsor.category}`,\n            start: currentSponsor.segment[1],\n          } as Chapter);\n        }\n\n        sponsorIndex++;\n      }\n    }\n\n    return result;\n  };\n  // createEffect(() => {\n  //   console.log(sponsorsQuery.data);\n  //   if (!sponsorsQuery.data) return;\n  //   const video = untrack(() => videoQuery.data);\n  //   if (!video) return;\n  //   const mergedChapters = mergeChaptersAndSponsors(\n  //     video.chapters,\n  //     sponsorsQuery.data\n  //   );\n  //   console.log(mergedChapters);\n  //   // setVideo(\"value\", \"chapters\", mergedChapters);\n  // });\n  //\n  // createEffect(() => {\n  //   setAppState({\n  //     loading:\n  //       videoQuery.isInitialLoading ||\n  //       videoQuery.isFetching ||\n  //       videoQuery.isRefetching,\n  //   });\n  // });\n  //\n  // createEffect(() => {\n  //   if (videoQuery.data) {\n  //     setVideo({ value: videoQuery.data });\n  //   }\n  // });\n  //\n  createEffect(() => {\n    if (!videoQuery.data) return;\n    document.title = `${videoQuery.data.title} - Conduit`;\n  });\n\n  const [playlistScrollContainer, setPlaylistScrollContainer] = createSignal<\n    HTMLDivElement | undefined\n  >();\n\n  const [listId, setListId] = createSignal<string | undefined>(undefined);\n  createEffect(() => {\n    if (!route.query.list) {\n      setPlaylist(undefined);\n      return;\n    }\n  });\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // createEffect(async () => {\n  //   if (!route.query.list) return;\n  //   if (isLocalPlaylist()) return;\n  //   const json = await fetchJson(\n  //     `${instance().api_url}/playlists/${route.query.list}`\n  //   );\n  //   setPlaylist({ ...json, id: route.query.list });\n  //   console.log(json);\n  // });\n\n  createEffect(async () => {\n    if (!route.query.list) {\n      setPlaylist(undefined);\n      console.log(\"fetching playlist no list id\");\n      return;\n    }\n    if (!isLocalPlaylist()) return;\n    console.log(\"fetching playlist\");\n    setListId(route.query.list);\n    console.log(\"fetching playlistlist id\", listId());\n    if (!listId()) return;\n    const list = sync.store.playlists[listId()!];\n    console.log(\"setting playlist\", list);\n    setPlaylist(list);\n    setTimeout(() => {\n      playlistScrollContainer()?.scrollTo({\n        top: route.query.index ? Number(route.query.index) * 80 : 0,\n        behavior: \"smooth\",\n      });\n    }, 100);\n  });\n  createEffect(() => {\n    setAppState(\"player\", \"dismissed\", false);\n    setAppState(\"player\", \"small\", false);\n  });\n\n  const [windowWidth, setWindowWidth] = createSignal(1000);\n\n  onMount(() => {\n    setWindowWidth(window.innerWidth);\n    window.addEventListener(\"resize\", (e) => {\n      setWindowWidth(window.innerWidth);\n    });\n\n    onCleanup(() => {\n      window.removeEventListener(\"resize\", (e) => {\n        setWindowWidth(window.innerWidth);\n      });\n    });\n  });\n  return (\n    <div\n      class=\"flex\"\n      classList={{\n        \"flex-col\": !!searchParams.fullscreen,\n        \"flex-col lg:flex-row\": !searchParams.fullscreen,\n      }}\n    >\n      <div\n        class=\"flex flex-col\"\n        classList={{\n          \"flex-grow\": !searchParams.fullscreen,\n          \"w-full\": !!searchParams.fullscreen,\n        }}\n      >\n        {/* <Switch>\n            <Match when={videoQuery.isLoading && !video.value}>\n              <PlayerLoading />\n            </Match>\n            <Match when={videoQuery.error}>\n              <PlayerError error={videoQuery.error as Error} />\n            </Match>\n            <Match when={videoQuery.data}> */}\n        <Show when={searchParams.fullscreen}>\n          <div class=\"h-[calc(100vh-2rem)]\" />\n        </Show>\n        {/* </Match>\n          </Switch> */}\n      </div>\n      <div class=\"flex sm:flex-row flex-col md:gap-2 w-full\">\n        <div class=\"w-full max-w-full\">\n          <Description downloaded={videoDownloaded()} />\n          <Show when={(windowWidth() > 600 || isMobile()) && videoQuery.data}>\n            <div class=\"mx-4\">\n              <Comments\n                videoId={getVideoId(videoQuery.data)!}\n                uploader={videoQuery.data!.uploader}\n                display={windowWidth() > 600 ? \"default\" : \"bottomsheet\"}\n              />\n            </div>\n          </Show>\n        </div>\n        <div\n          class={`flex flex-col gap-2 items-center w-full min-w-0 max-w-max`}\n        >\n          <Show when={playlist()} keyed>\n            {(list) => (\n              <div\n                role=\"group\"\n                aria-label=\"Playlist\"\n                class=\"overflow-hidden rounded-xl w-full p-2 max-w-[400px] min-w-0\"\n              >\n                <div\n                  ref={setPlaylistScrollContainer}\n                  class=\"relative flex flex-col gap-2 min-w-full md:min-w-[20rem] w-full bg-bg2 max-h-[30rem] px-1 overflow-y-auto scrollbar\"\n                >\n                  <h3 class=\"sticky top-0 left-0 z-10 text-lg font-bold sm:text-xl \">\n                    {list.name} - {route.query.index} /{\" \"}\n                    {list.relatedStreams.length}\n                  </h3>\n                  <For each={list.relatedStreams}>\n                    {(item, index) => {\n                      return (\n                        <PlaylistItem\n                          list={route.query.list}\n                          index={index() + 1}\n                          v={item}\n                          active={route.query.index ?? 1}\n                        />\n                      );\n                    }}\n                  </For>\n                </div>\n              </div>\n            )}\n          </Show>\n          <div class=\"relative max-w-max sm:max-w-min\">\n            <RelatedVideos />\n          </div>\n        </div>\n        <Show when={windowWidth() <= 600 && !isMobile() && videoQuery.data}>\n          <Comments\n            videoId={getVideoId(videoQuery.data)!}\n            uploader={videoQuery.data!.uploader}\n            display=\"default\"\n          />\n        </Show>\n      </div>\n    </div>\n  );\n}\n"],"names":["readManifestFileFromDirectory","directory","manifestFile","console","log","file","getFileHandle","getFile","text","split","rebuildManifest","manifestContent","content","segmentIndex","line","includes","segmentFileHandle","segmentFile","segmentUrl","URL","createObjectURL","replace","Blob","getHlsManifest","videoId","time","videoDirectory","navigator","storage","getDirectory","getDirectoryHandle","create","audioDirectory","videoDirectoryHandle","audioManifestContent","videoManifestContent","audioContentUrl","videoContentUrl","indexManifestHandle","indexFile","indexContent","timeEnd","getStreams","storageRoot","streamsFile","streams","JSON","parse","Error","thumbnailFile","thumbnailUrl","channelIconFileHandle","channelIconFile","channelIconUrl","subtitles","uploaderAvatar","subtitlesDirectory","code","subtitleFile","subtitleUrl","push","url","error","length","previewFramesDirectory","urls","index","frameUrl","previewFrames","frameFile","RelatedVideos","v","setV","createSignal","undefined","preferences","usePreferences","searchParams","useSearchParams","createEffect","sync","useSyncStore","videoQuery","createQuery","queryKey","instance","api_url","queryFn","api","fetchVideo","enabled","refetchOnReconnect","refetchOnMount","cacheTime","Infinity","staleTime","deferStream","_$createComponent","Show","when","data","fallback","For","each","Array","fill","children","VideoCard","_$ssr","_tmpl$","_$ssrHydrationKey","_$escape","relatedStreams","filter","item","store","blocklist","uploaderUrl","pop","stream","Switch","Match","type","layout","PlaylistCard","DEFAULT_THRESHOLD","VELOCITY_THRESHOLD","Bottomsheet","props","isSnapVariant","variant","maxHeight","setMaxHeight","window","visualViewport","height","isClosing","setIsClosing","isSnapping","setIsSnapping","getDefaultTranslateValue","defaultValue","defaultSnapPoint","innerHeight","getSnapPoints","snapPoints","sort","a","b","clampInRange","minimum","maximum","current","Math","min","max","bottomsheetTranslateValue","setBottomsheetTranslateValue","onViewportChange","onMount","addEventListener","onCleanup","removeEventListener","touchStartPosition","lastTouchPosition","acceptIds","Set","lastTouchTime","velocityY","onTouchStart","event","has","target","id","isEventFromContentChildren","timeStamp","touches","clientY","preventDefault","stopPropagation","contentScrollTop","setContentScrollTop","onTouchMoveHandle","dragDistance","currentTime","timeDelta","previousVal","wait","ms","Promise","resolve","setTimeout","isInertialScrolling","lastScrollTop","onTouchEnd","currentPoint","closestPoint","swipeDuration","swipeDistance","swipeVelocity","abs","reduce","currentVal","parentElement","sbHandle","options","passive","Portal","_tmpl$3","_$ssrElement","_$mergeProps","classList","style","transform","onAnimationEnd","onClose","_tmpl$2","Comment","showingReplies","setShowingReplies","fetchComments","pageParam","fetchJson","nextpage","comment","repliesPage","query","createInfiniteQuery","commentId","getNextPageParam","lastPage","initialPageParam","sanitizedText","setSanitizedText","sanitizeText","commentText","_tmpl$4","Link","href","commentorUrl","_$ssrAttribute","thumbnail","uploader","author","verified","_tmpl$7","commentedTime","Suspense","_tmpl$8","FaSolidThumbsUp","likeCount","replyCount","_tmpl$9","_tmpl$10","_tmpl$6","_tmpl$11","pages","flat","map","page","comments","hasNextPage","_tmpl$5","Comments","fetch","json","playerHeight","setPlayerHeight","player","document","querySelector","clientHeight","commentsOpen","setCommentsOpen","intersectionRef","setIntersectionRef","isIntersecting","useIntersectionObserver","setTarget","fetchNextPage","display","c","Watch","Date","toISOString","route","useLocation","playlist","setPlaylist","usePlaylist","videoDownloaded","setVideoDownloaded","downloaded","manifest","e","appState","setAppState","useAppState","isLocalPlaylist","list","startsWith","sponsorsQuery","sha256Encrypted","globalThis","crypto","subtle","digest","TextEncoder","encode","prefix","from","Uint8Array","toString","padStart","join","slice","urlObj","set","stringify","res","ok","status","reject","video","find","videoID","segments","isServer","retry","suspense","useErrorBoundary","playlistQuery","isSuccess","title","playlistScrollContainer","setPlaylistScrollContainer","listId","setListId","setSearchParams","playlists","scrollTo","top","Number","behavior","windowWidth","setWindowWidth","innerWidth","fullscreen","Description","isMobile","getVideoId","keyed","name","PlaylistItem","active"],"mappings":"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"}